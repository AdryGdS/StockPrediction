# -*- coding: utf-8 -*-
"""ML Stock Market.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pw5Ct1mOt9RTgsKUbppJ-QCJPSFwt1xD
"""

import pandas as pd

df = pd.read_csv('GSPC.csv')
df.head()

df = df.drop('Date', axis = 1)

df[-2::]

amanha = df[-1::]
amanha

#amanha df[-10::]
#amanha.to_csv('/content/sample_data/futuro.csv', index=False)

base = df.drop(df[-1::].index, axis = 0)
base.tail()

#base = df.drop(df[-10::].index, axis = 0)
#base.to_csv('/content/sample_data/hoje.csv', index=False)

"""Até aqui foi realizado tratamento de dados, removendo a última linha (que seria hoje) para realizar a prediçao de amanha."""

base['target'] = base['Close'][1:len(base)].reset_index(drop=True)
base.tail()

prev = base[-1::].drop('target', axis = 1)
prev

treino = base.drop(base[-1::].index, axis = 0)
treino.tail()

# Criar a coluna de target: se o fechamento de amanhã for maior que o de hoje
base['target'] = base['Close'][1:len(base)].reset_index(drop=True)
base.tail()

# Preparar os dados para previsão (remover a coluna target da última linha)
prev = base[-1::].drop('target', axis=1)

# Separar os dados de treino (remover a última linha de base)
treino = base.drop(base[-1::].index, axis=0)
treino.tail()

# Definir 1 para target quando o valor de fechamento de amanhã for maior que o de hoje
treino.loc[treino['target'] > treino['Close'], 'target'] = 1

# Definir 0 para target quando o valor de fechamento de amanhã não for maior
treino.loc[treino['target'] != 1, 'target'] = 0

# Separar as variáveis dependentes (y) e independentes (x)
y = treino['target']
x = treino.drop('target', axis=1)

# Separar os dados de treino e teste
from sklearn.model_selection import train_test_split
x_treino, x_teste, y_treino, y_teste = train_test_split(x, y, test_size=0.3)

# Criar e treinar o modelo de classificação Extra Trees
from sklearn.ensemble import ExtraTreesClassifier
modelo = ExtraTreesClassifier()
modelo.fit(x_treino, y_treino)

# Avaliar a acurácia do modelo
resultado = modelo.score(x_teste, y_teste)
print("Acurácia:", resultado)

# Fazer a previsão para os dados de amanhã
prev['target'] = modelo.predict(prev)

# Exibir a previsão de amanhã
print("\nPrevisão para amanhã:")
print(prev)

# Converter as previsões em mensagens
def converter_previsao(previsao):
    if previsao == 1:
        return "Invista, a previsão é positiva!"
    else:
        return "Não invista, a previsão é negativa!"

# Aplicar a conversão das previsões
prev['mensagem'] = prev['target'].apply(converter_previsao)

# Mostrar a previsão final com mensagens
print("\nPrevisões com mensagens:")
print(prev[['target', 'mensagem']])

# Adicionar a previsão ao DataFrame base (para manter a continuidade dos dados)
base = pd.concat([base, amanha], ignore_index=True, sort=True)
base.tail()
